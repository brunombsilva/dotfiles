#!/usr/bin/env bash
# ~/.bashrc: executed by bash(1) for non-login shells.

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

unset color_prompt force_color_prompt

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi


#TODO: Review From Here

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

export GIT_COMMITTER_NAME='Bruno Silva'
export GIT_COMMITTER_EMAIL='bruno.b.silva@co.sapo.pt'
export GIT_AUTHOR_NAME='Bruno Silva'
export GIT_AUTHOR_EMAIL='bruno.b.silva@co.sapo.pt'

# RVM
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"

working_directory() {
    dir=`pwd`
    in_home=0
    #if [[ `pwd` =~ ^$HOME($|\/) ]]; then
    if echo `pwd` | grep -E "^$HOME($|\/)" > /dev/null
    then
        dir="~${dir#$HOME}"
        in_home=1
    fi

    if [[ `tput cols &> /dev/null` -lt 100 ]]; then  # <-- Checking the term width
        first="/`echo $dir | cut -d / -f 2`"
        letter=${first:0:2}
        if [[ $in_home == 1 ]]; then
            letter="~$letter"
        fi
        proj=`echo $dir | cut -d / -f 3`
        beginning="$letter/$proj"

        end=`echo "$dir" | rev | cut -d / -f1 | rev`

        if [[ $proj == "" ]]; then
            echo $dir
        elif [[ $proj == "~" ]]; then
            echo $dir
        #elif [[ $dir =~ "$first/$proj"$ ]]; then
        elif echo $dir | grep -E "$first/$proj"$ > /dev/null
        then
            echo $beginning
        #elif [[ $dir =~ "$first/$proj/$end"$ ]]; then
        elif echo $dir | grep -E "$first/$proj/$end$" > /dev/null
        then
            echo "$beginning/$end"
        else
            echo "$beginning/…/$end"
        fi
    else
        echo $dir
    fi
}

# GIT branch on prompt
parse_git_branch() {
    #echo ""
   branch=`git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1/"`

    if [[ `tput cols &> /dev/null` -lt 100 ]]; then  # <---- Again checking the term width
        branch=`echo $branch | sed s/feature/f/1`
        branch=`echo $branch | sed s/hotfix/h/1`
        branch=`echo $branch | sed s/release/\r/1`
        branch=`echo $branch | sed s/master/mstr/1`
        branch=`echo $branch | sed s/develop/dev/1`
    fi

    if [[ $branch != "" ]]; then
        echo "($branch) "
    fi
}

git_status_color() {
    #echo ""
   [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit (working directory clean)" ]] && \
   echo -e "\033[0;33m" || \
   echo -e "\033[1;30m"
}

PS1="\n\[\033[1;30m\]\u@\h \[\033[0;32m\]\$(working_directory) \$(git_status_color)\$(parse_git_branch)\[\033[1;31m\]\nλ \[\033[0m\]"

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
   export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
   export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
   tput sgr0
   if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
       ORANGE=$(tput setaf 172)
       GREEN=$(tput setaf 70)
       PURPLE=$(tput setaf 141)
       WHITE=$(tput setaf 256)
   else
       ORANGE=$(tput setaf 4)
       GREEN=$(tput setaf 2)
       PURPLE=$(tput setaf 1)
       WHITE=$(tput setaf 7)
   fi
   BOLD=$(tput bold)
   RESET=$(tput sgr0)
else
   ORANGE="\033[1;33m"
   GREEN="\033[1;32m"
   PURPLE="\033[1;35m"
   WHITE="\033[1;37m"
   BOLD=""
   RESET="\033[m"
fi

export ORANGE
export GREEN
export WHITE
export BOLD
export RESET

# SVN messages editor
export SVN_EDITOR='vim'

[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"  # This loads RVM into a shell session.

export PATH=$PATH:.

#if which fortune >/dev/null; then
    #if [[ -e /var/lib/gems/1.8/bin/lolcat ]]; then
        #fortune riddles | lolcat
    #else
        #fortune
    #fi
#fi

#export HISTIGNORE="ls:ls *:cd:cd -:pwd;exit:date:* --help:fg"
export HISTIGNORE="pwd;exit:date:* --help:fg"
export EDITOR="vim"

# Autocorrect typos in path names when using `cd`
shopt -s cdspell

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2)" scp sftp ssh

# Highlight section titles in manual pages
export LESS_TERMCAP_md="$ORANGE"

[[ -s /user/local/bin/tmuxinator ]] && source .user/local/bin/tmuxinator


[ -z "$VIMPAGER_PATH" ] && export VIMPAGER_PATH=~/Dropbox/Programs/vimpager

if [[ -e "$VIMPAGER_PATH" ]]; then
    export PAGER=$VIMPAGER_PATH/vimpager
    export CAT=$VIMPAGER_PATH/vimcat
    export MANPAGER="$VIMPAGER_PATH/vimpager"
    alias cat=$CAT
    #alias less=$PAGER
    #alias zless=$PAGER
else
    export MANPAGER="less -X"
fi

export POWERLINE_DISABLED=1

if ! [[ -n "$POWERLINE_DISABLED" ]]; then
    [ -z "$POWERLINE_PATH" ] && export POWERLINE_PATH=~/Dropbox/Programs/powerline
    export PATH=$PATH:$POWERLINE_PATH/scripts/
    export PYTHONPATH=$POWERLINE_PATH/build/lib
    . $POWERLINE_PATH/powerline/bindings/bash/powerline.sh
fi

#sudo phpcs --config-set default_standard PSR2
export PATH="$HOME/.rbenv/bin:$PATH"
#eval "$(rbenv init -)"

tmup () 
{ 
    echo -n "Updating to latest tmux environment...";
    export IFS=",";
    for line in $(tmux showenv -t $(tmux display -p "#S") | tr "\n" ",");
    do
        if [[ $line == -* ]]; then
            unset $(echo $line | cut -c2-);
        else
            export $line;
        fi;
    done;
    unset IFS;
    echo "Done"
}

vg () 
{
    cd ~/Vagrant/$1 > /dev/null 2>&1
    if [ $? != 0 ]; then
        echo 'Invalid Vagrant Project'
        return -1
    fi
    shift
    vagrant $@
    cd - > /dev/null
}

_vg()
{
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    case "$COMP_CWORD" in
        1) words=`ls -p ~/Vagrant/ | sed '/puppet\|template\|.*[^\/]$/d' | tr -d '/'`;;
        2) words='box destroy halt help init package plugin provision reload resume ssh ssh-config status suspend up';;
        *) words='';;
    esac
    COMPREPLY=( $( compgen -W "$words" -- $cur ) )
}
complete -o default -o nospace -F _vg vg
alias vagrant=vg
complete -o default -o nospace -F _vg vagrant

#TODO: check windows environment
if [ $TERM = 'cygwin' ]; then 
    base='/c/Dropbox/Programs'

    export PATH="$PATH:$base/util-linux-ng/bin"
    export PATH="$PATH:$base/Kitty"
    export PATH="$PATH:$base/unzip/bin"
    export PATH="$PATH:$base/wget/bin"
    export PATH="$PATH:$base/unrar/bin"~

    export GIT_SSH="klink"

    alias locate="$base/findutils/bin/locate --database='$base/findutils/var/locatedb'"
    export BINDIR="$base/findutils/bin"
    export LIBEXECDIR="$base/findutils/libexec"
    alias updatedb="$base/findutils/bin/updatedb --output=/c/Dropbox/Programs/findutils/var/locatedb"
    alias vim="$base/gVimPortable/App/vim/vim73/vim --cmd 'set encoding=utf8' -c 'colorscheme default'"
    alias gvim="$base/gVimPortable/gVimPortable"

    _kitty()
    {
     cur=${COMP_WORDS[COMP_CWORD]}
     prev=${COMP_WORDS[COMP_CWORD-1]}
     COMPREPLY=( $( compgen -W "$(ls $base/kitty/Sessions | sed '/Default%20Settings/d')" -- $cur ) )
    }
    complete -o default -o nospace -F _kitty kitty

    auto_alias() {
        folder=$1
        exclude=$2
        if [ -z $exclude ]; then
            exclude='^$'
        fi
        aliases=`ls "$folder"/*/*.exe | \
                 sed 's/\.exe//Ig' | \
                 sed "/$exclude/Id" | \
                 awk -F "/" '{alias=$NF; sub(/ /,"", alias); print alias "() \{ \"" $0 ".exe\" \$@; \};"  }'`
        eval $aliases
    }
    auto_alias $base 
    auto_alias '/c/Program Files' 'instal\|Setup\|uninst\|config'
    auto_alias '/c/Program Files (x86)' 'instal\|Setup\|uninst\|config\|Mouse\|Defender'

    alias kitty="kitty -load"

fi

