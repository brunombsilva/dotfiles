# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

#if [ "$color_prompt" = yes ]; then
    #PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
#else
    #PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
#fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
#case "$TERM" in
#xterm*|rxvt*)
    #PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    #;;
#*)
    #;;
#esac

alias ls='ls --color=auto'
# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

# Rails
alias r='rake'
alias rcuc='rake cucumber:ok'
alias rcucmt='rake cucumber:mt'

# GIT
alias gb='git branch --color'
alias gba='git branch --color -a'
alias gc='git commit -v'
alias gst='git status'
alias gco='git checkout'
alias gpush='git push'
alias gpull='git pull'
alias gadd='git add -i'
alias gmerge='git merge'
alias gd='git diff HEAD'

export GIT_COMMITTER_NAME='Bruno Silva'
export GIT_COMMITTER_EMAIL='bruno.b.silva@co.sapo.pt'
export GIT_AUTHOR_NAME='Bruno Silva'
export GIT_AUTHOR_EMAIL='bruno.b.silva@co.sapo.pt'

# RVM
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"

# p4merge
alias rmorig="find . -name *.orig -exec /bin/rm -f '{}' \;"

working_directory() {
    dir=`pwd`
    in_home=0
    #if [[ `pwd` =~ ^$HOME($|\/) ]]; then
    if echo `pwd` | grep -E "^$HOME($|\/)" > /dev/null
    then
        dir="~${dir#$HOME}"
        in_home=1
    fi

    if [[ `tput cols &> /dev/null` -lt 100 ]]; then  # <-- Checking the term width
        first="/`echo $dir | cut -d / -f 2`"
        letter=${first:0:2}
        if [[ $in_home == 1 ]]; then
            letter="~$letter"
        fi
        proj=`echo $dir | cut -d / -f 3`
        beginning="$letter/$proj"

        end=`echo "$dir" | rev | cut -d / -f1 | rev`

        if [[ $proj == "" ]]; then
            echo $dir
        elif [[ $proj == "~" ]]; then
            echo $dir
        #elif [[ $dir =~ "$first/$proj"$ ]]; then
        elif echo $dir | grep -E "$first/$proj"$ > /dev/null
        then
            echo $beginning
        #elif [[ $dir =~ "$first/$proj/$end"$ ]]; then
        elif echo $dir | grep -E "$first/$proj/$end$" > /dev/null
        then
            echo "$beginning/$end"
        else
            echo "$beginning/…/$end"
        fi
    else
        echo $dir
    fi
}

# GIT branch on prompt
parse_git_branch() {
   branch=`git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1/"`

    if [[ `tput cols &> /dev/null` -lt 100 ]]; then  # <---- Again checking the term width
        branch=`echo $branch | sed s/feature/f/1`
        branch=`echo $branch | sed s/hotfix/h/1`
        branch=`echo $branch | sed s/release/\r/1`
        branch=`echo $branch | sed s/master/mstr/1`
        branch=`echo $branch | sed s/develop/dev/1`
    fi

    if [[ $branch != "" ]]; then
        echo "($branch) "
    fi
}

#function parse_git_branch {
  #git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\ \[\1\]/'
#}

PS1="\n\[\033[0m\]\u@\h \[\033[0;32m\]\$(working_directory) \[\033[0;33m\]\$(parse_git_branch)\[\033[0;31m\]\nλ \[\033[0m\]"

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
   export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
   export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
   tput sgr0
   if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
       ORANGE=$(tput setaf 172)
       GREEN=$(tput setaf 70)
       PURPLE=$(tput setaf 141)
       WHITE=$(tput setaf 256)
   else
       ORANGE=$(tput setaf 4)
       GREEN=$(tput setaf 2)
       PURPLE=$(tput setaf 1)
       WHITE=$(tput setaf 7)
   fi
   BOLD=$(tput bold)
   RESET=$(tput sgr0)
else
   ORANGE="\033[1;33m"
   GREEN="\033[1;32m"
   PURPLE="\033[1;35m"
   WHITE="\033[1;37m"
   BOLD=""
   RESET="\033[m"
fi

export ORANGE
export GREEN
export WHITE
export BOLD
export RESET

function parse_git_dirty() {
    #exit 
   [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit (working directory clean)" ]] && echo "*"
}

#function parse_git_branch() {
   #git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1/"
#}

function _git_prompt() {
    local git_status="`git status -unormal 2>&1`"
    #if ! [[ "$git_status" =~ Not\ a\ git\ repo ]]; then
    if ! echo "$git_status" | grep -E "Not\ a\ git\ repo" > /dev/null 
    then
        #if [[ "$git_status" =~ nothing\ to\ commit ]]; then
        if echo "$git_status" | grep -E "nothing\ to\ commit" > /dev/null 
        then
            local ansi=43
        #elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
        elif echo "$git_status" | grep -E "nothing\ added\ to\ commit\ but\ untracked\ files\ present" 
        then
            local ansi=43
        else
            local ansi=45
        fi
        #if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
        if echo "$git_status" | grep -E "On\ branch\ ([^[:space:]]+)" 
        then
            branch=${BASH_REMATCH[1]}
            test "$branch" != master || branch=' '
            branch=' ' #don't show branch
        else
            # Detached HEAD.  (branch=HEAD is a faster alternative.)
            branch="(`git describe --all --contains --abbrev=4 HEAD 2> /dev/null ||
                echo HEAD`)"
        fi
        echo -n '\[\e[0;37;'"$ansi"';1m\]'"$branch"'\[\e[0m\] '
    fi
}

#PS1="`_git_prompt`""\[${BOLD}${GREEN}\]\u\[$WHITE\] @ \[$PURPLE\]\h\[$WHITE\]:\[$GREEN\]\w\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" (\")\[$ORANGE\]\$(parse_git_branch)\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \")\")\n\$ \[$RESET\]"


# SVN messages editor
export SVN_EDITOR='vim'

[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"  # This loads RVM into a shell session.

alias likeabossHTTP='python -c "import SimpleHTTPServer;SimpleHTTPServer.test()" &'

alias php_syntax='find ./ -type f -name \*.php -exec php -l {} \; | grep -v "^No syntax errors detected in"'

alias lolcat='/var/lib/gems/1.8/bin/lolcat'
#alias dramalho='sudo'

export PATH=$PATH:.

#if which fortune >/dev/null; then
    #if [[ -e /var/lib/gems/1.8/bin/lolcat ]]; then
        #fortune riddles | lolcat
    #else
        #fortune
    #fi
#fi

#export HISTIGNORE="ls:ls *:cd:cd -:pwd;exit:date:* --help:fg"
export HISTIGNORE="pwd;exit:date:* --help:fg"
export EDITOR="vim"

# Easier navigation: .., ..., ~ and -
alias ..="cd .."
alias ...="cd ../.."
alias ~="cd ~" # `cd` is probably faster to type though
alias -- -="cd -"
# IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias ips="ifconfig -a | perl -nle'/(\d+\.\d+\.\d+\.\d+)/ && print $1'"

# View HTTP traffic
alias sniff="sudo ngrep -d 'eth0' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i eth0 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""

# Autocorrect typos in path names when using `cd`
shopt -s cdspell

# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2)" scp sftp ssh

# Highlight section titles in manual pages
export LESS_TERMCAP_md="$ORANGE"

[[ -s /user/local/bin/tmuxinator ]] && source .user/local/bin/tmuxinator


[ -z "$VIMPAGER_PATH" ] && export VIMPAGER_PATH=~/Dropbox/Programs/vimpager

if [[ -e "$VIMPAGER_PATH" ]]; then
    export PAGER=$VIMPAGER_PATH/vimpager
    export CAT=$VIMPAGER_PATH/vimcat
    export MANPAGER="$VIMPAGER_PATH/vimpager"
    alias cat=$CAT
    #alias less=$PAGER
    #alias zless=$PAGER
else
    export MANPAGER="less -X"
fi

export POWERLINE_DISABLED=1

if ! [[ -n "$POWERLINE_DISABLED" ]]; then
    [ -z "$POWERLINE_PATH" ] && export POWERLINE_PATH=~/Dropbox/Programs/powerline
    export PATH=$PATH:$POWERLINE_PATH/scripts/
    export PYTHONPATH=$POWERLINE_PATH/build/lib
    . $POWERLINE_PATH/powerline/bindings/bash/powerline.sh
fi

#sudo phpcs --config-set default_standard PSR2
export PATH="$HOME/.rbenv/bin:$PATH"
#eval "$(rbenv init -)"

alias mem-used="top -b -n 1 | grep -Po '(?<=Mem:).*free' | sed 's/ *\([0-9]*\)k total, *\([0-9]*\)k used, *\([0-9]*\)k free/Mem: \3 \/ \1/'"


alias readable="chmod -R a+r .; find . -type d -exec chmod a+xr {} \;"


tmup () 
{ 
    echo -n "Updating to latest tmux environment...";
    export IFS=",";
    for line in $(tmux showenv -t $(tmux display -p "#S") | tr "\n" ",");
    do
        if [[ $line == -* ]]; then
            unset $(echo $line | cut -c2-);
        else
            export $line;
        fi;
    done;
    unset IFS;
    echo "Done"
}

#TODO: check windows environment
if [ $TERM = 'cygwin' ]; then 
    base='/c/Dropbox/Programs'

    export PATH="$PATH:$base/util-linux-ng/bin"
    export PATH="$PATH:$base/Kitty"
    export PATH="$PATH:$base/unzip/bin"
    export PATH="$PATH:$base/wget/bin"
    export PATH="$PATH:$base/unrar/bin"~

    export GIT_SSH="klink"

    alias locate="$base/findutils/bin/locate --database='$base/findutils/var/locatedb'"
    export BINDIR="$base/findutils/bin"
    export LIBEXECDIR="$base/findutils/libexec"
    alias updatedb="$base/findutils/bin/updatedb --output=/c/Dropbox/Programs/findutils/var/locatedb"
    alias vim="$base/gVimPortable/App/vim/vim73/vim --cmd 'set encoding=utf8' -c 'colorscheme default'"
    alias gvim="$base/gVimPortable/gVimPortable"

fi
