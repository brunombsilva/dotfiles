"let $pwd = getcwd() 
if !exists('$POWERLINE_PATH')
    if has('win32') || has('win64')
        let $POWERLINE_PATH = $VIMRUNTIME.'\\..\\..\\..\\..\\..\\Programs\\powerline'
    else
        let $POWERLINE_PATH = '~/Dropbox/Programs/powerline'
    endif
endif
if !exists('$PATHOGEN_PATH')
    if has('win32') || has('win64')
        let $PATHOGEN_PATH = $VIMRUNTIME.'\\..\\..\\..\\..\\..\\Config\\vim\\_vim\\bundle'
    else
        let $PATHOGEN_PATH = '$HOME/.vim/bundle'
    endif
endif
let g:pathogen_disabled = ['DBGp-client']

if has('win32') || has('win64')
    set runtimepath=$VIMRUNTIME\\..\\..\\..\\..\\..\\Config\\vim\\_vim,$VIMRUNTIME\\..\\..\\..\\..\\..\\Config\\vim\\_vim\\plugin,$VIMRUNTIME
else
    set term=screen-256color
endif

runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect($PATHOGEN_PATH.'/{}') 
set runtimepath+=$POWERLINE_PATH/powerline/bindings/vim

"silent! call pathogen#helptags()

set nocompatible                  " Must come first because it changes other options.

syntax enable                     " Turn on syntax highlighting.
filetype plugin indent on         " Turn on file type detection.

runtime macros/matchit.vim        " Load the matchit plugin.

set showcmd                       " Display incomplete commands.
set showmode                      " Display the mode you're in.

set backspace=indent,eol,start    " Intuitive backspacing.

set hidden                        " Handle multiple buffers better.

set wildmenu                      " Enhanced command line completion.
set wildmode=list:longest         " Complete files like a shell.

set ignorecase                    " Case-insensitive searching.
set smartcase                     " But case-sensitive if expression contains a capital letter.

set number                        " Show line numbers.
set ruler                         " Show cursor position.

set incsearch                     " Highlight matches as you type.
set hlsearch                      " Highlight matches.

set wrap                          " Turn on line wrapping.
set scrolloff=3                   " Show 3 lines of context around the cursor.

set title                         " Set the terminal's title

set visualbell                    " No beeping.

set nobackup                      " Don't make a backup before overwriting a file.
set nowritebackup                 " And again.
if has("win32") || has("win64")
    set directory=$TMP
else    
    set directory=/tmp  " Keep swap files in one location
end
"set noswapfile

" UNCOMMENT TO USE
set tabstop=4                    " Global tab width.
set shiftwidth=4                 " And again, related.
set expandtab                    " Use spaces instead of tabs
set softtabstop=4

set laststatus=2                  " Show the status line all the time
" Useful status information at bottom of screen
set statusline=[%n]\ %<%.99f\ %h%w%m%r%y\ %{fugitive#statusline()}%{exists('*CapsLockStatusline')?CapsLockStatusline():''}%=%-16(\ %l,%c-%v\ %)%P
    
syntax enable

let g:solarized_termcolors=256
if has('win32') || has('win64')
    let g:solarized_degrade=1
endif
"let g:solarized_contrast="high"
"let g:solarized_visibility="high"

set t_Co=16
set background=dark
colorscheme solarized 
"colorscheme wombat


" Tab mappings.
map <leader>tt :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>to :tabonly<cr>
map <leader>tn :tabnext<cr>
map <leader>tp :tabprevious<cr>
map <leader>tf :tabfirst<cr>
map <leader>tl :tablast<cr>
map <leader>tm :tabmove
"Rename tabs to show tab# and # of viewports
if exists("+showtabline")
    function! MyTabLine()
        let s = ''
        let wn = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%1*' : '%2*')
            let s .= ''
            let wn = tabpagewinnr(i,'$')

            let s .= (i== t ? '%#TabNumSel#' : '%#TabNum#')
            let s .= ' '.i
            "if tabpagewinnr(i,'$') > 1
                "let s .= '.'
                "let s .= (i== t ? '%#TabWinNumSel#' : '%#TabWinNum#')
                "let s .= (tabpagewinnr(i,'$') > 1 ? wn : '')
            "end

            let s .= ' %*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let bufnr = buflist[winnr - 1]
            let file = bufname(bufnr)
            let buftype = getbufvar(bufnr, 'buftype')
            if buftype == 'nofile'
                if file =~ '\/.'
                    let file = substitute(file, '.*\/\ze.', '', '')
                endif
            else
                let file = fnamemodify(file, ':p:t')
            endif
            if file == ''
                let file = '[No Name]'
            endif
            let s .= file
            let s .= (i == t ? '%m' : '')
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        return s
    endfunction
    "set stal=2
    set tabline=%!MyTabLine()
endif

"set tabpagemax=15
hi TabLineSel term=underline cterm=underline ctermfg=239 ctermbg=187 gui=bold
hi TabNumSel term=underline cterm=underline ctermfg=239 ctermbg=187 gui=bold

"nmap <C-S-tab> :tabprevious<cr>
"nmap <C-S-tab> :tabnext<cr>
"imap <C-S-tab> <ESC>:tabprevious<cr>i
"imap <C-tab> <ESC>:tabnext<cr>i
"nmap <C-t> :tabnew<cr>
"imap <C-t> <ESC>:tabnew<cr>i
"map <C-w> :tabclose<cr>

imap <leader>fl <Esc><leader>fl
map <leader>fl :TlistToggle<cr><C-w>h<C-w>h<C-w>h

imap <leader>nt <Esc><leader>nt
map <leader>nt :NERDTreeToggle<cr>
map <leader>tb :TagbarToggle<cr>


" Automatic fold settings for specific files. Uncomment to use.
 autocmd FileType php setlocal foldmethod=syntax
" autocmd FileType css  setlocal foldmethod=indent shiftwidth=2 tabstop=2
let g:php_folding=0

" For the MakeGreen plugin and Ruby RSpec. Uncomment to use.
"autocmd BufNewFile,BufRead *_spec.rb compiler rspec

"autocmd FileType php set omnifunc=phpcomplete#CompletePHP
"autocmd FileType html set omnifunc=htmlcomplete#CompleteTag
"autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS

autocmd FileType php set keywordprg=pman
au BufRead,BufNewFile *.tpl set filetype=smarty

"let g:manpageview_pgm_php = "pman"
"let g:manpageview_options_php = ""
"let g:manpageview_sfx_php = ""
":au FileType html,xml,xsl,smarty source ~/.vim/plugin/closetag.vim

set nocp
if version >= 600
    filetype plugin indent on
endif

set mouse=n   
let g:spchkmouse   = 1
let g:spchkautonext= 1
let g:spchkdialect = "usa" 

let g:ConqueTerm_CloseOnEnd = 1
"let g:ConqueTerm_InsertOnEnter = 0
let g:ConqueTerm_ToggleKey = '<F3>'


"let g:acp_behaviorSnipmateLength = 4
let g:acp_behaviorKeywordLength = 5
"let g:acp_behaviourHtmlOmniLength = 4

set autoindent                              "Retain indentation on next line
set smartindent                             "Turn on autoindenting of blocks
set cinwords = ""                           "But not for C-like keywords
inoremap # X<C-H>#|                         "And no magic outdent for comments
nnoremap <silent> >> :call ShiftLine()<CR>| "And no shift magic on comments

function! ShiftLine()
    set nosmartindent
    normal! >>
    set smartindent
endfunction

set backspace=indent,eol,start      "BS past autoindents, line boundaries,
set matchpairs+=<:>             "Match angle brackets too


"Switch off highlighting till next search and clear messages...
nmap <silent> <BS> :nohlsearch <BAR> set nocursorcolumn<CR>

" Use space to jump down a page (like browsers do)...
noremap <Space> <PageDown>

"=====[ Correct common mistypings in-the-fly ]=======================

iab    retrun  return
iab     pritn  print
iab       teh  the
iab      liek  like
iab  liekwise  likewise
iab      Pelr  Perl
iab      pelr  perl
iab        ;t  't
iab      moer  more
iab  previosu  previous

"shortcut to rapidly toggle `set list`
nmap <leader>l :set list!<CR>
"Use the same symbols as TextMate for tabstops and EOLs
"set listchars=tab:<.,eol:Â¬

"Invisible character colors
"highlight NonText guifg=#4a4a59
"highlight SpecialKey guifg=#4a4a59

let g:bufExplorerShowTabBuffer=1 

hi DbgCurrent term=reverse ctermfg=White ctermbg=Red gui=reverse
hi DbgBreakPt term=reverse ctermfg=Red ctermbg=DarkGrey gui=reverse

let g:debuggerMaxDepth = 2

function! LoadCscope()
  let db = findfile("cscope.out", ".;")
  if (!empty(db))
    let path = strpart(db, 0, match(db, "/cscope.out$"))
    set nocscopeverbose " suppress 'duplicate connection' error
    exe "cs add " . db . " " . path
    set cscopeverbose
  endif
endfunction
au BufEnter /* call LoadCscope()

nmap <leader>csu  :!find . -iname '*.php' -o -iname '*.tpl' > cscope.files<CR>
  \:!cscope -b -i cscope.files -f cscope.out<CR>
  \:cs reset<CR>

"vmap <C-c> "+y
"nmap <C-v> p
"imap <C-v> <Esc><C-v>a

" XML
autocmd FileType xml setlocal foldmethod=syntax
let loaded_xmledit = 1

map <leader>ys :YRShow<cr>

" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode silent call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

" autocmds to automatically enter hex mode and handle file writes properly
if has("autocmd")
  " vim -b : edit binary using xxd-format!
  augroup Binary
    au!

    " set binary option for all binary files before reading them
    au BufReadPre *.bin,*.hex setlocal binary

    " if on a fresh read the buffer variable is already set, it's wrong
    au BufReadPost *
          \ if exists('b:editHex') && b:editHex |
          \   let b:editHex = 0 |
          \ endif

    " convert to hex on startup for binary files automatically
    au BufReadPost *
          \ if &binary | Hexmode | endif

    " When the text is freed, the next time the buffer is made active it will
    " re-read the text and thus not match the correct mode, we will need to
    " convert it again if the buffer is again loaded.
    au BufUnload *
          \ if getbufvar(expand("<afile>"), 'editHex') == 1 |
          \   call setbufvar(expand("<afile>"), 'editHex', 0) |
          \ endif

    " before writing a file when editing in hex mode, convert back to non-hex
    au BufWritePre *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  silent exe "%!xxd -r" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif

    " after writing a binary file, if we're in hex mode, restore hex mode
    au BufWritePost *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  silent exe "%!xxd" |
          \  exe "set nomod" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
  augroup END
endif

map <C-b> :% ! php_beautifier<CR>

autocmd FileType html,xml exe 'setlocal equalprg=tidy\ -quiet\ -indent\ --indent-spaces\ 4\ --wrap\ 0\ -xml\ -f\ '.&errorfile

au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

let g:syntastic_auto_loc_list=1
let g:syntastic_loc_list_height=3
"let g:syntastic_quiet_warnings=1
let g:syntastic_php_phpmd_post_args = 'design,unusedcode'
let g:syntastic_php_phpcs_args = '--standard=PSR2'

"let g:syntastic_mode_map = { 'mode': 'active', 'active_filetypes': ['php'], 'passive_filetypes': [''] }

"GuiColorScheme railscasts2

 autocmd FileType php setlocal comments=s1:/**,mb:*,ex:*/,://,:#

fu! DoRunPyBuffer2()
pclose! " force preview window closed
setlocal ft=python

" copy the buffer into a new window, then run that buffer through python
sil %y a | below new | sil put a | sil %!python -
" indicate the output window as the current previewwindow
setlocal previewwindow ro nomodifiable nomodified

" back into the original window
winc p
endfu

command! RunPyBuffer call DoRunPyBuffer2()
map <Leader>py :RunPyBuffer<CR>

set ttymouse=xterm2
set mouse=a

set clipboard=unnamed
let g:php_cs_fixer_path = "/usr/local/bin/php-cs-fixer"
"let g:php_cs_fixer_fixers_list = "indentation,linefeed,traling_spaces,unused_use,php_closing_tags,eof_ending,extra_empty_lines,control_spaces,elseif"

if exists('vimcat') 
    hi Normal ctermbg=16
else
    hi Normal ctermbg=None
    hi LineNr ctermfg=235 ctermbg=Black
    hi SignColumn ctermbg=None
endif

let g:snipMate = {}
let g:snipMate['scope_aliases'] = {'php':'php'}

map <leader>ps :PSearch<cr>
map <leader>ps* :PSearchw<cr><cr>

if has("autocmd") && exists("+omnifunc")
    autocmd Filetype *
            \   if &omnifunc == "" |
            \       setlocal omnifunc=syntaxcomplete#Complete |
            \   endif
endif

imap <C-Space> <C-x><C-o>
imap <C-@> <C-Space>
set completeopt=longest,menu,preview

"let g:neocomplcache_enable_at_startup = 1

autocmd FileType smarty let b:match_words = '<:>,<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'

let g:tagbar_left = 1

map <leader>ide :NERDTree<cr>:TagbarOpen<cr><C-w>t<C-w>s:buffer NERD_tree_1<cr><C-w>t<C-w>l<C-w>c<C-w>t


